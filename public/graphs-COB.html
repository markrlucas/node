<!DOCTYPE html>
<html lang="en" style="height: 100%">
<head>
  <meta charset="UTF-8">
  <title>Charts</title>
  <script>
    // Set symbol from localStorage or default
    const symbol = localStorage.getItem('selectedSymbol') || 'ZROUSDT';
    document.addEventListener('DOMContentLoaded', () => {
      document.title = `Charts (${symbol})`;
      // Populate symbol dropdown
      const SYMBOLS = ['BTCUSDT','ETHUSDT', 'XRPUSDT'];
      const symbolDropdown = document.createElement('select');
      symbolDropdown.id = 'symbol-dropdown';
      symbolDropdown.className = 'toolbar-btn';
      SYMBOLS.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = s;
        if (s === symbol) opt.selected = true;
        symbolDropdown.appendChild(opt);
      });
      const toolbar = document.getElementById('top-toolbar');
      toolbar.insertBefore(symbolDropdown, toolbar.firstChild);
      symbolDropdown.addEventListener('change', () => {
        localStorage.setItem('selectedSymbol', symbolDropdown.value);
        location.reload();
      });
    });
  </script>
  <style>
    html, body { margin: 0; height: 100vh; width: 100vw; font-family: Arial; background: #333; display: grid; grid-template-rows: 50px 1fr; }
    #top-toolbar { display: flex; align-items: center; justify-content: center; background: linear-gradient(145deg,#fff,#e6e6e6); padding: 10px 15px; border-bottom:2px solid #aaa; gap:10px; }
    .icon { width:18px; height:18px; vertical-align:middle; }
    .toolbar-btn { background: linear-gradient(to bottom,#fff,#d9d9d9); border:1px solid #888; padding:5px 10px; font-size:14px; cursor:pointer; border-radius:4px; transition:0.1s; }
    .toolbar-btn.pressed, .toolbar-btn:active { background:#ccc; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2); transform: translateY(2px); }
    .toolbar-btn:hover { background:#eee; }
    .separator { color:#484848; margin:0 10px; }

    /* Widget slate (container) */
    #chart-container { height: calc(100vh - 50px); width: 100vw; display: flex; align-items: stretch; justify-content: center; padding: 18px; box-sizing: border-box; background: linear-gradient(180deg,#e6ecf3,#dfe7ee); }

    /* Chart widget: fills container and shows a 5px white 3D border */
    .chart {
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      background: #ffffff; /* chart drawing area */
      border: 5px solid #ffffff; /* bright white "frame" */
      border-radius: 8px;
      position: relative;
      /* subtle 3D lift */
      box-shadow: 0 14px 28px rgba(0,0,0,0.22), 0 6px 12px rgba(0,0,0,0.12), inset 0 -6px 8px rgba(0,0,0,0.03);
      overflow: hidden;
    }

    /* Annotation canvas overlays the chart precisely */
    #annotation-canvas { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:2; }

    /* Top-left control panel inside the chart - hidden by default, shown when .open is applied */
    .chart-controls {
      display: none;
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 5;
      background: rgba(255,255,255,0.92);
      border-radius: 8px;
      padding: 8px 10px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.12);
      font-size: 13px;
      color: #111;
      min-width: 220px;
      backdrop-filter: blur(4px);
      transition: opacity 0.18s ease, transform 0.18s ease;
      opacity: 0;
      transform: translateY(-6px);
      pointer-events: none;
    }
    .chart-controls.open { display: block; opacity: 1; transform: translateY(0); pointer-events: auto; }
    .chart-controls label { display:flex; justify-content:space-between; gap:8px; align-items:center; margin:6px 0; }
    .chart-controls input[type='number'], .chart-controls input[type='text'], .chart-controls select { width:100px; font-size:13px; padding:4px 6px; border-radius:4px; border:1px solid #cfcfcf; }
    .chart-controls .ctl-row { display:flex; justify-content:space-between; gap:8px; align-items:center; }
    .chart-controls .ctl-actions { display:flex; gap:8px; margin-top:6px; justify-content:flex-end; }
    .chart-controls .btn { background:#f3f3f3; border:1px solid #d0d0d0; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:13px; }
  </style>
</head>
<body>
  <div id="top-toolbar">
    <select id="timeframe" class="toolbar-btn">
      <option value="1m" selected>1m</option>
      <option value="5m">5m</option>
      <option value="15m">15m</option>
      <option value="1h">1h</option>
      <option value="4h">4h</option>
    </select>
    <button id="chart-type" class="toolbar-btn">üìà</button>
    <button id="fullscreen" class="toolbar-btn">‚õ∂</button>
  <button id="settings" class="toolbar-btn">‚öô</button>
  <button id="toggle-controls" class="toolbar-btn" title="Chart Controls">‚öôÔ∏é</button>
    <button id="toggle-candles" class="toolbar-btn" title="Toggle Candlesticks on COB Chart">üïØÔ∏è</button>
    <button id="adaptive-mode" class="toolbar-btn" title="Toggle Adaptive Granularity">üéØ</button>
    <span class="separator">|</span>
    <button id="annotate" class="toolbar-btn"><img src="./img/pencil-icon.svg" alt="Annotate" class="icon"></button>
    <button id="erase" class="toolbar-btn"><img src="./img/eraser-icon.svg" alt="Erase" class="icon"></button>
    <button id="stack-charts" class="toolbar-btn" title="Stack visible charts">üóÑÔ∏è Stack Charts</button>
  </div>
  <div id="chart-container">
    <div id="pluginChartCOB" class="chart">
      <canvas id="annotation-canvas"></canvas>
      <div class="chart-controls" id="chart-controls" aria-label="Chart controls">
        <div class="ctl-title">Chart Controls <button id="ctl-close" class="btn" title="Close">‚úï</button></div>
        <div class="ctl-row"><label>priceRange <input id="ctl-priceRange" type="number" step="0.0001"></label></div>
        <div class="ctl-row"><label>pricePrecision <input id="ctl-pricePrecision" type="number" step="1"></label></div>
        <div class="ctl-row"><label>priceGrouping <input id="ctl-priceGrouping" type="number" step="0.0001"></label></div>
        <div class="ctl-row"><label>percentageThresholdForLabel <input id="ctl-percentageThresholdForLabel" type="number" step="0.1"></label></div>
        <div class="ctl-row"><label>showPercentageInLabels <input id="ctl-showPercentageInLabels" type="checkbox"></label></div>
        <div class="ctl-row"><label>labelMinVolume <input id="ctl-labelMinVolume" type="number" step="1"></label></div>
        <div class="ctl-row"><label>labelRoundTo <input id="ctl-labelRoundTo" type="number" step="1"></label></div>
        <div class="ctl-row"><label>minDataPointsForVWAP <input id="ctl-minDataPointsForVWAP" type="number" step="1"></label></div>
        <div class="ctl-row"><label>maxHistory <input id="ctl-maxHistory" type="number" step="1"></label></div>
        <div class="ctl-row"><label>maxHeatmapHistory <input id="ctl-maxHeatmapHistory" type="number" step="1"></label></div>
        <div class="ctl-row"><label>adaptiveGranularity <input id="ctl-adaptiveGranularity" type="checkbox"></label></div>
        <div class="ctl-row"><label>vwapZoneRange <input id="ctl-vwapZoneRange" type="number" step="0.0001"></label></div>
        <div class="ctl-row"><label>distantWallThreshold <input id="ctl-distantWallThreshold" type="number" step="0.1"></label></div>
        <div class="ctl-row"><label>enablePriceLine <input id="ctl-enablePriceLine" type="checkbox"></label></div>
        <div class="ctl-row"><label>priceLineColor <input id="ctl-priceLineColor" type="color"></label></div>
        <div class="ctl-row"><label>priceLineOpacity <input id="ctl-priceLineOpacity" type="number" step="0.01" min="0" max="1"></label></div>
        <div class="ctl-row"><label>priceLineWidth <input id="ctl-priceLineWidth" type="number" step="1"></label></div>
        <div class="ctl-row"><label>priceLineGlowColor <input id="ctl-priceLineGlowColor" type="color"></label></div>
        <div class="ctl-row"><label>priceLineGlowBlur <input id="ctl-priceLineGlowBlur" type="number" step="1"></label></div>
        <div class="ctl-row"><label>percentageThresholdColorVariance <input id="ctl-percentageThresholdColorVariance" type="number" step="1"></label></div>
        <div class="ctl-row"><label>maxPercentageThresholdColorVariance <input id="ctl-maxPercentageThresholdColorVariance" type="number" step="1"></label></div>
        <div class="ctl-row"><label>debug <input id="ctl-debug" type="checkbox"></label></div>
        <div class="ctl-actions"><button class="btn" id="ctl-apply">Apply</button><button class="btn" id="ctl-reset">Reset</button></div>
      </div>
    </div>
  </div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@4/dist/echarts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts-gl@1/dist/echarts-gl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts-stat@1/dist/ecStat.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@4/dist/extension/dataTool.min.js"></script>
  <script src="../charts/pluginChartCOB.js"></script>
  <script src="../includes/WebSocketClient.js"></script>

  <script>
    // --- WebSocket & Chart Init (unchanged) ---
    document.addEventListener('DOMContentLoaded',()=>{
      try {
        window.pluginChartCOB = new PluginChartCOB({
          containerId: 'pluginChartCOB',
          symbol,
          cobWebSocketUrl: `wss://realm.sanixlab.com/wss/`,
          enableCandlesticks: true,
			  klineWebSocketUrl: `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@kline_1m`,
          candlestickOpacity: 0.75,
          maxVisibleCandles: 1,
          priceRange: symbol === 'BTCUSDT' ? 0.003 : symbol === 'ETHUSDT' ? 0.010 : symbol === 'XRPUSDT' ? 0.02 : 0.02,
          pricePrecision: symbol === 'BTCUSDT' ? 0 : symbol === 'ETHUSDT' ? 3 : symbol === 'XRPUSDT' ? 3 : 3,
          priceGrouping: symbol === 'BTCUSDT' ? 5 : symbol === 'ETHUSDT' ? 0.5 : symbol === 'XRPUSDT' ? 0.0005 : 0.0005,
          percentageThresholdForLabel: 15,
          adaptiveGranularity: true,
          vwapZoneRange: 0.002,
          distantWallThreshold: 20.0
        });
        window.pluginChartCOB.initialize();
        // ensure chart and overlay fill widget
        function resizeWidget() {
          const widget = document.getElementById('pluginChartCOB');
          if (!widget) return;
          // ensure echarts instance resizes (plugin or fallback to echarts instance)
          if (window.pluginChartCOB && typeof window.pluginChartCOB.resize === 'function') {
            try { window.pluginChartCOB.resize(); } catch(e){ console.warn('chart resize error', e); }
          } else {
            try {
              const dom = document.getElementById('pluginChartCOB');
              const inst = window.echarts && window.echarts.getInstanceByDom && window.echarts.getInstanceByDom(dom);
              if (inst && typeof inst.resize === 'function') inst.resize();
            } catch(e){ /* ignore */ }
          }
          const canvas = widget.querySelector('#annotation-canvas');
          if (canvas) {
            canvas.width = widget.clientWidth;
            canvas.height = widget.clientHeight;
          }
        }
        // call once and on window resize
        setTimeout(resizeWidget, 120);
        window.addEventListener('resize', resizeWidget);
        console.log(`üöÄ PluginChartCOB initialized for ${symbol}`);
      } catch(e){console.error('PluginChartCOB',e)}
    });

    // --- Chart controls wiring ---
    function getCtl(id){ return document.getElementById(id); }
    function populateControls() {
          const ids = ['priceRange','pricePrecision','priceGrouping','percentageThresholdForLabel','showPercentageInLabels','labelMinVolume','labelRoundTo','minDataPointsForVWAP','maxHistory','maxHeatmapHistory','adaptiveGranularity','vwapZoneRange','distantWallThreshold','enablePriceLine','priceLineColor','priceLineOpacity','priceLineWidth','priceLineGlowColor','priceLineGlowBlur','percentageThresholdColorVariance','maxPercentageThresholdColorVariance','debug'];
          const opts = (window.pluginChartCOB && window.pluginChartCOB.options) || {};
          // Populate each control safely
          ids.forEach(k => {
            const el = getCtl('ctl-' + k);
            if (!el) return;
            const val = opts[k] !== undefined ? opts[k] : {
              priceRange: (window.selectedPriceRange || 0.01),
              pricePrecision: (window.selectedPricePrecision || 3),
              priceGrouping: (window.selectedPriceGrouping || 0.0005),
              percentageThresholdForLabel: 15,
              showPercentageInLabels: false,
              labelMinVolume: 0,
              labelRoundTo: 1,
              minDataPointsForVWAP: 5,
              maxHistory: 30,
              maxHeatmapHistory: 30,
              adaptiveGranularity: true,
              vwapZoneRange: 0.007,
              distantWallThreshold: 0.1,
              enablePriceLine: true,
              priceLineColor: '#ffd600',
              priceLineOpacity: 0.9,
              priceLineWidth: 4,
              priceLineGlowColor: '#ffff80',
              priceLineGlowBlur: 18,
              percentageThresholdColorVariance: 8,
              maxPercentageThresholdColorVariance: 30,
              debug: false
            }[k];
            if (el.type === 'checkbox') el.checked = Boolean(val);
            else el.value = (val !== undefined && val !== null) ? val : '';
          });
    }

    function applyControls() {
          // collect values from all controls
          const newOpts = {};
          const collect = ['priceRange','pricePrecision','priceGrouping','percentageThresholdForLabel','labelMinVolume','labelRoundTo','minDataPointsForVWAP','maxHistory','maxHeatmapHistory','vwapZoneRange','distantWallThreshold','priceLineOpacity','priceLineWidth','priceLineGlowBlur','percentageThresholdColorVariance','maxPercentageThresholdColorVariance'];
          collect.forEach(k => {
            const el = getCtl('ctl-' + k);
            if (!el) return;
            const v = el.type === 'number' || el.type === 'text' ? el.value : el.value;
            if (v === '') return;
            newOpts[k] = (el.type === 'number' || el.type === 'text') ? parseFloat(v) : v;
          });
          // booleans and colors
          ['showPercentageInLabels','adaptiveGranularity','enablePriceLine','debug'].forEach(k => {
            const el = getCtl('ctl-' + k); if (!el) return; newOpts[k] = !!el.checked;
          });
          ['priceLineColor','priceLineGlowColor'].forEach(k => { const el = getCtl('ctl-' + k); if (!el) return; newOpts[k] = el.value; });
      // Prefer a plugin-provided update method
      try {
        if (window.pluginChartCOB && typeof window.pluginChartCOB.updateOptions === 'function') {
          window.pluginChartCOB.updateOptions(newOpts);
        } else if (window.pluginChartCOB && typeof window.pluginChartCOB.setOptions === 'function') {
          window.pluginChartCOB.setOptions(Object.assign({}, window.pluginChartCOB.options || {}, newOpts));
        } else if (window.pluginChartCOB) {
          // lazy-assign and trigger a resize/re-render
          window.pluginChartCOB.options = Object.assign({}, window.pluginChartCOB.options || {}, newOpts);
          // trigger an immediate update path that is safe
          try {
            // update internal state and schedule a redraw
            if (typeof window.pluginChartCOB.scheduleUpdate === 'function') {
              window.pluginChartCOB.scheduleUpdate();
            } else if (typeof window.pluginChartCOB.updateHeatmapData === 'function' && typeof window.pluginChartCOB.renderChart === 'function') {
              window.pluginChartCOB.updateHeatmapData();
              window.pluginChartCOB.renderChart();
            } else if (typeof window.pluginChartCOB.resize === 'function') {
              window.pluginChartCOB.resize();
            } else {
              const dom = document.getElementById('pluginChartCOB');
              const inst = window.echarts && window.echarts.getInstanceByDom && window.echarts.getInstanceByDom(dom);
              if (inst && typeof inst.resize === 'function') inst.resize();
            }
          } catch(err) { console.warn('forced update failed', err); }
        }
      } catch(err){ console.warn('applyControls failed', err); }
    }

    document.addEventListener('DOMContentLoaded', ()=>{
      // small delay to ensure pluginChartCOB created
      setTimeout(()=>{
        populateControls();
        const applyBtn = getCtl('ctl-apply');
        const resetBtn = getCtl('ctl-reset');
        if (applyBtn) {
          applyBtn.addEventListener('click', applyControls);
        } else { console.warn('Chart controls: apply button not found'); }
        if (resetBtn) {
          resetBtn.addEventListener('click', ()=>{ populateControls(); applyControls(); });
        } else { console.warn('Chart controls: reset button not found'); }
        // Auto-apply on control change with debounce
        let autoApplyTimer = null;
        const autoApplyDebounce = 350; // ms
  const inputs = Array.from(document.querySelectorAll('#chart-controls input')) || [];
  if (inputs.length === 0) console.warn('Chart controls: no inputs found for auto-apply');
  inputs.forEach(inp => {
          const ev = inp.type === 'checkbox' ? 'change' : 'input';
          inp.addEventListener(ev, ()=>{
            if (autoApplyTimer) clearTimeout(autoApplyTimer);
            autoApplyTimer = setTimeout(()=>{ applyControls(); }, autoApplyDebounce);
          });
        });
        // Toggle button in toolbar to show/hide controls
  const toggleBtn = document.getElementById('toggle-controls');
  const panel = document.getElementById('chart-controls');
  const closeBtn = document.getElementById('ctl-close');
  // ensure panel starts closed
  if (panel) {
    panel.classList.remove('open');
    panel.setAttribute('aria-hidden', 'true');
  } else {
    console.warn('Chart controls panel not found');
  }
  if (toggleBtn) toggleBtn.setAttribute('aria-expanded', 'false');
  if (toggleBtn && panel) {
    toggleBtn.addEventListener('click', ()=>{
      const open = panel.classList.toggle('open');
      panel.setAttribute('aria-hidden', open ? 'false' : 'true');
      toggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
      console.log('Chart controls toggled:', open);
      if (open) populateControls();
    });
  }
  if (closeBtn && panel) closeBtn.addEventListener('click', ()=>{ panel.classList.remove('open'); panel.setAttribute('aria-hidden','true'); if (toggleBtn) toggleBtn.setAttribute('aria-expanded','false'); });
          // Make control panel draggable/resizable using interact.js if available
          try {
            if (window.interact && panel) {
              interact(panel).draggable({ inertia:true, modifiers:[interact.modifiers.restrictRect({restriction:'parent',endOnly:true})], listeners:{move(e){ const t=e.target; const x=(parseFloat(t.getAttribute('data-x'))||0)+e.dx; const y=(parseFloat(t.getAttribute('data-y'))||0)+e.dy; t.style.transform=`translate(${x}px,${y}px)`; t.setAttribute('data-x',x); t.setAttribute('data-y',y); }}}).resizable({ edges:{left:true,right:true,top:true,bottom:true}, modifiers:[interact.modifiers.restrictEdges({outer:'parent'}), interact.modifiers.restrictSize({min:{width:200,height:120}})], listeners:{move(e){ const t=e.target; t.style.width=e.rect.width+'px'; t.style.height=e.rect.height+'px'; const x=parseFloat(t.getAttribute('data-x'))||0, y=parseFloat(t.getAttribute('data-y'))||0; t.style.transform=`translate(${x}px,${y}px)`; } } });
            }
          } catch(err){ /* ignore if interact missing */ }
      }, 200);
    });

    // --- Draggable & Resizable charts (guarded: only initialize if interact available) ---
    try {
      if (window.interact && typeof window.interact === 'function') {
        interact('.chart').draggable({ inertia:true, modifiers:[interact.modifiers.restrictRect({restriction:'parent',endOnly:true})], listeners:{move(e){
          const t=e.target, x=(parseFloat(t.getAttribute('data-x'))||0)+e.dx, y=(parseFloat(t.getAttribute('data-y'))||0)+e.dy;
          t.style.transform=`translate(${x}px,${y}px)`; t.setAttribute('data-x',x); t.setAttribute('data-y',y);
        }}}).resizable({ edges:{left:true,right:true,top:true,bottom:true}, modifiers:[interact.modifiers.restrictEdges({outer:'parent'}),interact.modifiers.restrictSize({min:{width:150,height:120}})], listeners:{move(e){
            const t=e.target;
            // Apply size and keep transform
            t.style.width=e.rect.width+'px';
            t.style.height=e.rect.height+'px';
            const x=parseFloat(t.getAttribute('data-x'))||0, y=parseFloat(t.getAttribute('data-y'))||0;
            t.style.transform=`translate(${x}px,${y}px)`;
            // Notify chart instance to resize if available, otherwise fallback to echarts instance
            try {
              if (window.pluginChartCOB && typeof window.pluginChartCOB.resize === 'function') {
                window.pluginChartCOB.resize();
              } else {
                const dom = document.getElementById(t.id);
                const inst = window.echarts && window.echarts.getInstanceByDom && window.echarts.getInstanceByDom(dom);
                if (inst && typeof inst.resize === 'function') inst.resize();
              }
            } catch(err){ console.warn('chart resize failed', err); }
            // Resize annotation canvas overlay inside the chart
            const canvas = t.querySelector && t.querySelector('#annotation-canvas');
            if (canvas) {
              canvas.width = t.clientWidth;
              canvas.height = t.clientHeight;
            }
        } } });
      } else {
        console.info('interact.js not detected: chart drag/resize disabled');
      }
    } catch(err) { console.warn('failed to initialize chart interact handlers', err); }

    // --- Annotation Tools ---
    const annotationCanvas=document.getElementById('annotation-canvas'), ctx=annotationCanvas.getContext('2d'), toolbar=document.getElementById('top-toolbar');
    let annotateMode=false, currentTool='freehand', drawingColor='#ff0000', isDrawing=false, startX=0, startY=0;
    const shapes=[];

    function resizeAnnotationCanvas(){ annotationCanvas.width=annotationCanvas.parentElement.offsetWidth; annotationCanvas.height=annotationCanvas.parentElement.offsetHeight; if(!annotateMode) ctx.clearRect(0,0,annotationCanvas.width,annotationCanvas.height); }
    window.addEventListener('load', ()=>{ resizeAnnotationCanvas(); setTimeout(resizeAnnotationCanvas,300); });
    window.addEventListener('resize', resizeAnnotationCanvas);

    // Color Picker
    const colorPicker=document.createElement('input'); colorPicker.type='color'; colorPicker.value=drawingColor; colorPicker.className='toolbar-btn'; colorPicker.oninput=e=>drawingColor=e.target.value; toolbar.appendChild(colorPicker);

    // Tool Selector
    const toolSelector=document.createElement('select'); toolSelector.className='toolbar-btn'; ['freehand','line','rectangle','circle'].forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; toolSelector.append(o); }); toolSelector.onchange=e=>{ if(annotateMode){ isDrawing=false; currentTool=e.target.value; }}; toolbar.appendChild(toolSelector);

    // Annotate Toggle
    const annotateBtn=document.getElementById('annotate'); annotateBtn.onclick=()=>{ annotateMode=!annotateMode; annotationCanvas.style.pointerEvents=annotateMode?'auto':'none'; annotateBtn.classList.toggle('pressed',annotateMode); if(!annotateMode) redraw(); };

    // Erase
    document.getElementById('erase').onclick=()=>{ ctx.clearRect(0,0,annotationCanvas.width,annotationCanvas.height); shapes.length=0; };

    // Draw and preview
    annotationCanvas.addEventListener('mousedown',e=>{ if(!annotateMode||e.button!==0) return; isDrawing=true; startX=e.offsetX; startY=e.offsetY; if(currentTool==='freehand'){ ctx.beginPath(); ctx.moveTo(startX,startY);} });
    annotationCanvas.addEventListener('mousemove',e=>{ if(!annotateMode||!isDrawing) return; const x=e.offsetX, y=e.offsetY; ctx.clearRect(0,0,annotationCanvas.width,annotationCanvas.height); redraw(); if(currentTool==='freehand'){ ctx.lineTo(x,y); ctx.strokeStyle=drawingColor; ctx.lineWidth=2; ctx.stroke(); } else { ctx.strokeStyle=drawingColor; ctx.lineWidth=2; ctx.beginPath(); if(currentTool==='line'){ ctx.moveTo(startX,startY); ctx.lineTo(x,y); ctx.stroke(); } else if(currentTool==='rectangle'){ ctx.strokeRect(startX,startY,x-startX,y-startY); } else if(currentTool==='circle'){ const r=Math.hypot(x-startX,y-startY); ctx.arc(startX,startY,r,0,2*Math.PI); ctx.stroke(); } } });
    annotationCanvas.addEventListener('mouseup',e=>{ if(!annotateMode||!isDrawing) return; isDrawing=false; const x=e.offsetX, y=e.offsetY; if(currentTool==='line'){ shapes.push({type:'line',x1:startX,y1:startY,x2:x,y2:y,color:drawingColor}); } else if(currentTool==='rectangle'){ shapes.push({type:'rect',x:startX,y:startY,w:x-startX,h:y-startY,color:drawingColor}); } else if(currentTool==='circle'){ shapes.push({type:'circle',x:startX,y:startY,r:Math.hypot(x-startX,y-startY),color:drawingColor}); } });
    function redraw(){ ctx.clearRect(0,0,annotationCanvas.width,annotationCanvas.height); shapes.forEach(sh=>{ ctx.strokeStyle=sh.color; ctx.fillStyle=sh.color; if(sh.type==='line'){ ctx.beginPath(); ctx.moveTo(sh.x1,sh.y1); ctx.lineTo(sh.x2,sh.y2); ctx.stroke(); } else if(sh.type==='rect'){ ctx.strokeRect(sh.x,sh.y,sh.w,sh.h); } else if(sh.type==='circle'){ ctx.beginPath(); ctx.arc(sh.x,sh.y,sh.r,0,2*Math.PI); ctx.stroke(); } }); }
  </script>
</body>
</html>

