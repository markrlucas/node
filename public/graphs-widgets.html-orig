<!DOCTYPE html>
<html lang="en" style="height: 100%">
<head>
  <meta charset="UTF-8">
  <title>Charts</title>
  <script>
    // Set symbol from localStorage or default
    const symbol = localStorage.getItem('selectedSymbol') || 'ZROUSDT';
    document.addEventListener('DOMContentLoaded', () => {
      document.title = `Charts (${symbol})`;
      // Populate symbol dropdown
      const SYMBOLS = ['BTCUSDT','ETHUSDT', 'XRPUSDT'];
      const symbolDropdown = document.createElement('select');
      symbolDropdown.id = 'symbol-dropdown';
      symbolDropdown.className = 'toolbar-btn';
      SYMBOLS.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = s;
        if (s === symbol) opt.selected = true;
        symbolDropdown.appendChild(opt);
      });
      const toolbar = document.getElementById('top-toolbar');
      toolbar.insertBefore(symbolDropdown, toolbar.firstChild);
      symbolDropdown.addEventListener('change', () => {
        localStorage.setItem('selectedSymbol', symbolDropdown.value);
        location.reload();
      });
    });
  </script>
  <style>
    html, body { margin: 0; height: 100vh; width: 100vw; font-family: Arial; background: #333; display: grid; grid-template-rows: 50px 1fr; }
    #top-toolbar { display: flex; align-items: center; justify-content: center; background: linear-gradient(145deg,#fff,#e6e6e6); padding: 10px 15px; border-bottom:2px solid #aaa; gap:10px; }
    .icon { width:18px; height:18px; vertical-align:middle; }
    .toolbar-btn { background: linear-gradient(to bottom,#fff,#d9d9d9); border:1px solid #888; padding:5px 10px; font-size:14px; cursor:pointer; border-radius:4px; transition:0.1s; }
    .toolbar-btn.pressed, .toolbar-btn:active { background:#ccc; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2); transform: translateY(2px); }
    .toolbar-btn:hover { background:#eee; }
    .separator { color:#484848; margin:0 10px; }
    #chart-container { height:calc(100vh - 50px); width:100%; display:grid; grid-template-columns:1fr 1fr; grid-template-rows:1fr 1fr; gap:10px; padding:10px; position:relative; }
    .chart { width:100%; height:100%; background:#fff; border:1px solid #ccc; border-radius:6px; position:relative; }
    .delete-btn { position:absolute; top:5px; right:5px; background:#555; color:#fff; border:none; border-radius:50%; width:20px; height:20px; font-size:14px; cursor:pointer; z-index:2; }
    #annotation-canvas { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:1; }
  </style>
</head>
<body>
  <div id="top-toolbar">
    <select id="timeframe" class="toolbar-btn">
      <option value="1m" selected>1m</option>
      <option value="5m">5m</option>
      <option value="15m">15m</option>
      <option value="1h">1h</option>
      <option value="4h">4h</option>
    </select>
    <button id="chart-type" class="toolbar-btn">üìà</button>
    <button id="fullscreen" class="toolbar-btn">‚õ∂</button>
    <button id="settings" class="toolbar-btn">‚öô</button>
    <button id="toggle-candles" class="toolbar-btn" title="Toggle Candlesticks on COB Chart">üïØÔ∏è</button>
    <button id="adaptive-mode" class="toolbar-btn" title="Toggle Adaptive Granularity">üéØ</button>
    <span class="separator">|</span>
    <button id="annotate" class="toolbar-btn"><img src="./img/pencil-icon.svg" alt="Annotate" class="icon"></button>
    <button id="erase" class="toolbar-btn"><img src="./img/eraser-icon.svg" alt="Erase" class="icon"></button>
    <button id="stack-charts" class="toolbar-btn" title="Stack visible charts">üóÑÔ∏è Stack Charts</button>
  </div>
  <div id="chart-container">
    <div id="pluginChart1" class="chart"></div>
  <div id="pluginChart3" class="chart"></div>
  <div id="pluginChart2" class="chart"></div> 
  <div id="pluginChart4" class="chart"></div>
    <canvas id="annotation-canvas"></canvas>
  </div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@4/dist/echarts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts-gl@1/dist/echarts-gl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts-stat@1/dist/ecStat.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@4/dist/extension/dataTool.min.js"></script>
  <script src="../charts/pluginChart.js"></script>
  <script src="../charts/pluginChartCandles.js"></script>
  <script src="../charts/pluginChartCandlesVolume.js"></script>
  <script src="../charts/pluginChartCOB.js"></script>
  <script src="../includes/WebSocketClient.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>

  <script>
    // --- WebSocket & Chart Init (unchanged) ---
    const socketClient = new WebSocketClient('ws://192.168.91:8083');
    socketClient.on('open', () => console.log('Connected')); socketClient.on('close', () => console.log('Closed'));
    socketClient.on('error', e => console.error('WS error:',e));
    socketClient.on('message', async signal => {
      try {
        const raw = typeof signal==='string'?JSON.parse(signal):JSON.parse(await signal.text());
        const payload = raw.data||raw;
  
    // --- Stack Charts Button ---
    const stackBtn = document.getElementById('stack-charts');
    let stackedMode = false;
    stackBtn.addEventListener('click', () => {
      const chartContainer = document.getElementById('chart-container');
      const visibleCharts = Array.from(chartContainer.querySelectorAll('.chart')).filter(ch => ch.offsetParent !== null);
      if (!stackedMode) {
        chartContainer.classList.add('stacked');
        visibleCharts.forEach(ch => {
          ch.style.width = '100%';
          ch.style.height = '';
        });
        stackBtn.textContent = 'üî≥ Unstack Charts';
      } else {
        chartContainer.classList.remove('stacked');
        visibleCharts.forEach(ch => {
          ch.style.width = '';
          ch.style.height = '';
        });
        stackBtn.textContent = 'üóÑÔ∏è Stack Charts';
      }
      stackedMode = !stackedMode;
      setTimeout(adjustChartLayout, 300);
    });
        (Array.isArray(payload)?payload:[payload]).forEach(processTradeSignal);
      } catch(e){console.error('Msg failed',e)}
    });

    function processTradeSignal(d){
      
      if (d.positions && Object.keys(d.positions).length >= 1) {
        Object.entries(d.positions).forEach(([key, pos]) => {
          if (pos.symbol === symbol) {
            const p = {
              plugin: 'profitLossPlugin',
              action: 'PLOTTRADE',
              positions: { [key]: pos },
            };
            //console.log(`Position ${key}:`, pos);
            window.pluginChart1.receiveSignal(p);
          }
        });
      }

      if(!d || !d.plugin || d.symbol !== symbol) {
        
      // Check for positions with symbol matching current symbol
        return;
        // Handle ProfitLosslPlugin signals
      }
      //console.log('Accepted signal:', d);  // <-- Debugging line to see accepted signals

      switch(d.plugin){
        case 'GoldenCrossPlugin':
          console.log(`[${d.plugin}] Processing signal for ${d.symbol}`);
          console.log(d);
          window.pluginChart3.receiveSignal(d);
            break;
        case 'TradeUpdater':
          console.log(`[${d.plugin}] Processing TradeUpdater signal for ${d.symbol}`);
          window.pluginChart1.receiveSignal(d);
          break;
        case 'L2KDJPlugin':
          console.log(`[${d.plugin}] Processing L2KDJ signal for ${d.symbol}`);
          //console.log(d);
          window.pluginChart4.receiveSignal(d);
          break;
        case 'OrderBookWallsPlugin':
          if (d.buyWalls || d.sellWalls) {
            //console.log(`[${d.plugin}] BUY-SELL WALLS signal for ${JSON.stringify(d.buyWalls)}`);
            window.pluginChart1.receiveSignal(d);
          break;
          }
      }
    }
    
    
    function adjustChartLayout(){
      Object.values(window).filter(c=>c?.resize).forEach(c=>c.resize());
    }
    window.addEventListener('resize', adjustChartLayout);
    document.getElementById('fullscreen').addEventListener('click',()=>setTimeout(adjustChartLayout,300));

    // ‚úÖ Incredible COB Chart Controls
    document.getElementById('toggle-candles').addEventListener('click', () => {
      if (window.pluginChart2 && window.pluginChart2.options) {
        window.pluginChart2.options.enableCandlesticks = !window.pluginChart2.options.enableCandlesticks;
        window.pluginChart2.renderChart();
        const btn = document.getElementById('toggle-candles');
        btn.style.backgroundColor = window.pluginChart2.options.enableCandlesticks ? '#2d5a87' : '';
        console.log(`üïØÔ∏è Candlesticks ${window.pluginChart2.options.enableCandlesticks ? 'enabled' : 'disabled'}`);
      }
    });

    document.getElementById('adaptive-mode').addEventListener('click', () => {
      if (window.pluginChart2 && window.pluginChart2.options) {
        window.pluginChart2.options.adaptiveGranularity = !window.pluginChart2.options.adaptiveGranularity;
        window.pluginChart2.renderChart();
        const btn = document.getElementById('adaptive-mode');
        btn.style.backgroundColor = window.pluginChart2.options.adaptiveGranularity ? '#2d5a87' : '';
        console.log(`üéØ Adaptive granularity ${window.pluginChart2.options.adaptiveGranularity ? 'enabled' : 'disabled'}`);
      }
    });

    // --- Initialize Charts ---> plugincandles.js, pluginChart.js
    // Set symbol from localStorage or default
    
    // plugincharCanddles must fix the klineWebSocketUrl to use the plugin manager.    <------ THIS!!!
    

    document.addEventListener('DOMContentLoaded',()=>{
      try { window.pluginChart1=new PluginChartCandlesVolume({containerId:'pluginChart1',symbol,klineWebSocketUrl:`ws://192.168.0.91:8080?symbol=${symbol}&duration=1m&limit=30`}); window.pluginChart1.initialize(); } catch(e){console.error('Chart1',e)}
      try { 
        // ‚úÖ INCREDIBLE COB + Candlestick Chart with all WebSocket endpoints configured
        window.pluginChart2=new PluginChartCOB({
          containerId:'pluginChart2',
          symbol,
          cobWebSocketUrl:`ws://192.168.0.91:8084`, // Order book WebSocket
          // üöÄ ADD CANDLESTICK OVERLAY SUPPORT
          enableCandlesticks: true,
          klineWebSocketUrl:`ws://192.168.0.91:8080?symbol=${symbol}&duration=1m&limit=180`, // Candlestick WebSocket
          candlestickOpacity: 0.75,
          maxVisibleCandles: 1,
          // Enhanced settings for the incredible visualization
            priceRange: symbol === 'BTCUSDT' ? 0.003 : symbol === 'ETHUSDT' ? 0.010 : symbol === 'XRPUSDT' ? 0.02 : 0.02,
            pricePrecision: symbol === 'BTCUSDT' ? 0 : symbol === 'ETHUSDT' ? 3 : symbol === 'XRPUSDT' ? 3 : 3,
            priceGrouping: symbol === 'BTCUSDT' ? 5 : symbol === 'ETHUSDT' ? 0.5 : symbol === 'XRPUSDT' ? 0.0005 : 0.0005,
            percentageThresholdForLabel: symbol === 'BTCUSDT' ? 0.5 : symbol === 'ETHUSDT' ? 5 : symbol === 'XRPUSDT' ? 15.0 : 1.0,
          adaptiveGranularity: true,
          vwapZoneRange: 0.002,
          distantWallThreshold: 20.0
        }); 
        window.pluginChart2.initialize(); 
        console.log(`üöÄ Incredible COB+Candlestick chart initialized for ${symbol}`);
      } catch(e){console.error('Chart2 (Incredible COB)',e)}

      try { 
        window.pluginChart3=new PluginChartCandles(
          {
            containerId:'pluginChart3',symbol,pluginName:'AlphaBlendPlugin',indicatorKeys:[],markLines:[],klineWebSocketUrl:`ws://192.168.0.91:8080?symbol=${symbol}&duration=1m&limit=180`}); window.pluginChart3.initialize(); 
      } catch(e){console.error('Chart3',e)
      }

      try { window.pluginChart4=new PluginChart(
        {
          containerId:'pluginChart4',
          symbol,
          pluginName:'L2KDJPlugin',
          indicatorKeys:['K','D','J','whalePump','whaleBleed'],
          markLines:['20','green','80','red','110','purple','50','yellow'],
          yAxisMax:120,yAxisMin:-20}); 
          window.pluginChart4.initialize(); } catch(e){console.error('Chart4',e)
          }

      document.querySelectorAll('.chart').forEach(ch=>{ const btn=document.createElement('button');btn.className='delete-btn';btn.textContent='‚úï';btn.onclick=()=>ch.remove();ch.appendChild(btn); });

      // Stack Charts Button logic
      const stackBtn = document.getElementById('stack-charts');
      let stackedMode = false;
      stackBtn.addEventListener('click', () => {
        const chartContainer = document.getElementById('chart-container');
        const visibleCharts = Array.from(chartContainer.querySelectorAll('.chart')).filter(ch => ch.offsetParent !== null);
        if (!stackedMode) {
          chartContainer.classList.add('stacked');
          visibleCharts.forEach(ch => {
            ch.style.width = '100%';
            ch.style.height = '';
          });
          stackBtn.textContent = 'üî≥ Unstack Charts';
        } else {
          chartContainer.classList.remove('stacked');
          visibleCharts.forEach(ch => {
            ch.style.width = '';
            ch.style.height = '';
          });
          stackBtn.textContent = 'üóÑÔ∏è Stack Charts';
        }
        stackedMode = !stackedMode;
        setTimeout(adjustChartLayout, 300);
      });
    });

    // --- Draggable & Resizable charts ---
    interact('.chart').draggable({ inertia:true, modifiers:[interact.modifiers.restrictRect({restriction:'parent',endOnly:true})], listeners:{move(e){
      const t=e.target, x=(parseFloat(t.getAttribute('data-x'))||0)+e.dx, y=(parseFloat(t.getAttribute('data-y'))||0)+e.dy;
      t.style.transform=`translate(${x}px,${y}px)`; t.setAttribute('data-x',x); t.setAttribute('data-y',y);
    }}}).resizable({ edges:{left:true,right:true,top:true,bottom:true}, modifiers:[interact.modifiers.restrictEdges({outer:'parent'}),interact.modifiers.restrictSize({min:{width:100,height:100}})], listeners:{move(e){ const t=e.target; t.style.width=e.rect.width+'px'; t.style.height=e.rect.height+'px'; const x=parseFloat(t.getAttribute('data-x'))||0, y=parseFloat(t.getAttribute('data-y'))||0; t.style.transform=`translate(${x}px,${y}px)`; window[t.id]?.resize(); }} });

    // --- Annotation Tools ---
    const annotationCanvas=document.getElementById('annotation-canvas'), ctx=annotationCanvas.getContext('2d'), toolbar=document.getElementById('top-toolbar');
    let annotateMode=false, currentTool='freehand', drawingColor='#ff0000', isDrawing=false, startX=0, startY=0;
    const shapes=[];

    function resizeAnnotationCanvas(){ annotationCanvas.width=annotationCanvas.parentElement.offsetWidth; annotationCanvas.height=annotationCanvas.parentElement.offsetHeight; if(!annotateMode) ctx.clearRect(0,0,annotationCanvas.width,annotationCanvas.height); }
    window.addEventListener('load', ()=>{ resizeAnnotationCanvas(); setTimeout(resizeAnnotationCanvas,300); });
    window.addEventListener('resize', resizeAnnotationCanvas);

    // Color Picker
    const colorPicker=document.createElement('input'); colorPicker.type='color'; colorPicker.value=drawingColor; colorPicker.className='toolbar-btn'; colorPicker.oninput=e=>drawingColor=e.target.value; toolbar.appendChild(colorPicker);

    // Tool Selector
    const toolSelector=document.createElement('select'); toolSelector.className='toolbar-btn'; ['freehand','line','rectangle','circle'].forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; toolSelector.append(o); }); toolSelector.onchange=e=>{ if(annotateMode){ isDrawing=false; currentTool=e.target.value; }}; toolbar.appendChild(toolSelector);

    // Annotate Toggle
    const annotateBtn=document.getElementById('annotate'); annotateBtn.onclick=()=>{ annotateMode=!annotateMode; annotationCanvas.style.pointerEvents=annotateMode?'auto':'none'; annotateBtn.classList.toggle('pressed',annotateMode); if(!annotateMode) redraw(); };

    // Erase
    document.getElementById('erase').onclick=()=>{ ctx.clearRect(0,0,annotationCanvas.width,annotationCanvas.height); shapes.length=0; };

    // Draw and preview
    annotationCanvas.addEventListener('mousedown',e=>{ if(!annotateMode||e.button!==0) return; isDrawing=true; startX=e.offsetX; startY=e.offsetY; if(currentTool==='freehand'){ ctx.beginPath(); ctx.moveTo(startX,startY);} });
    annotationCanvas.addEventListener('mousemove',e=>{ if(!annotateMode||!isDrawing) return; const x=e.offsetX, y=e.offsetY; ctx.clearRect(0,0,annotationCanvas.width,annotationCanvas.height); redraw(); if(currentTool==='freehand'){ ctx.lineTo(x,y); ctx.strokeStyle=drawingColor; ctx.lineWidth=2; ctx.stroke(); } else { ctx.strokeStyle=drawingColor; ctx.lineWidth=2; ctx.beginPath(); if(currentTool==='line'){ ctx.moveTo(startX,startY); ctx.lineTo(x,y); ctx.stroke(); } else if(currentTool==='rectangle'){ ctx.strokeRect(startX,startY,x-startX,y-startY); } else if(currentTool==='circle'){ const r=Math.hypot(x-startX,y-startY); ctx.arc(startX,startY,r,0,2*Math.PI); ctx.stroke(); } } });
    annotationCanvas.addEventListener('mouseup',e=>{ if(!annotateMode||!isDrawing) return; isDrawing=false; const x=e.offsetX, y=e.offsetY; if(currentTool==='line'){ shapes.push({type:'line',x1:startX,y1:startY,x2:x,y2:y,color:drawingColor}); } else if(currentTool==='rectangle'){ shapes.push({type:'rect',x:startX,y:startY,w:x-startX,h:y-startY,color:drawingColor}); } else if(currentTool==='circle'){ shapes.push({type:'circle',x:startX,y:startY,r:Math.hypot(x-startX,y-startY),color:drawingColor}); } });
    function redraw(){ ctx.clearRect(0,0,annotationCanvas.width,annotationCanvas.height); shapes.forEach(sh=>{ ctx.strokeStyle=sh.color; ctx.fillStyle=sh.color; if(sh.type==='line'){ ctx.beginPath(); ctx.moveTo(sh.x1,sh.y1); ctx.lineTo(sh.x2,sh.y2); ctx.stroke(); } else if(sh.type==='rect'){ ctx.strokeRect(sh.x,sh.y,sh.w,sh.h); } else if(sh.type==='circle'){ ctx.beginPath(); ctx.arc(sh.x,sh.y,sh.r,0,2*Math.PI); ctx.stroke(); } }); }
  </script>
</body>
</html>
